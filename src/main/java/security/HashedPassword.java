/*
 * Copyright 2020 Oliver Trevor and Suchin Ravi.
 *
 * This file is part of MarkSpace.
 *
 * MarkSpace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarkSpace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MarkSpace.  If not, see <https://www.gnu.org/licenses/>.
 */

package security;

/** @file HashedPassword.java
 * The binary data of a hashed password, with some convenience functions for using it safely. Should only be used by other security.* classes and by storage.DatabaseStorage.
 * Use security.PasswordSecurity for all password-related stuff; never use this class directly from the outside (controllers, etc.).
 * @see security.HashedPassword
 */

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;

/**
 * A class that represents the binary data of a hashed password. This includes both the salt and the hash itself.
 * This class also has convenience functions for safely verifying a password using the hash.
 * See https://crackstation.net/hashing-security.htm and https://www.baeldung.com/java-password-hashing.
 */

public class HashedPassword {
    /**
     * The binary data of the salt.
     */
    private byte[] salt;

    /**
     * The binary data of the hash itself.
     */
    private byte[] hash;

    /**
     * Constant-time byte array comparison. Used to compare hashes in such a way that an attacker cannot deduce anything
     * by the amount of time it takes to check a hash.
     * Source: https://crackstation.net/hashing-security.htm
     * @param a A byte array to compare with b.
     * @param b A byte array to compare with a.
     * @return Returns true if they are equal, false if they are not.
     */
    private static boolean slowEquals(byte[] a, byte[] b) {
        int diff = a.length ^ b.length;
        for(int i = 0; i < a.length && i < b.length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    /**
     * Given a plaintext password and salt, hash the password using the salt and store the hash in this.hash.
     * @param salt The salt to use with the hash. MUST be SecurityParameters.PASSWORD_SALT_LENGTH_BYTES random bytes. MUST be different for every password. MUST be generated by a cryptographically secure random number generator.
     * @param password The plaintext password to hash.
     */
    private void hashPassword(byte[] salt, char[] password) {
        KeySpec keySpec = new PBEKeySpec(password, salt, SecurityParameters.PASSWORD_HASH_ITERATION_COUNT, SecurityParameters.PASSWORD_HASH_LENGTH_BYTES * 8);
        SecretKeyFactory secretKeyFactory;
        try {
            secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");
            hash = secretKeyFactory.generateSecret(keySpec).getEncoded();
        }
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            System.out.println("\033[1;31mFATAL ERROR: Cannot find password hashing algorithm 'PBKDF2WithHmacSHA512'.\033[0m");
            System.exit(-1);
        }
        catch (InvalidKeySpecException e) {
            e.printStackTrace();
            System.out.println("\033[1;31mFATAL ERROR: Invalid key spec exception.\033[0m");
            System.exit(-1);
        }
        for (int i = 0; i < password.length; i++) {
            password[i] = '\0';
        }
    }

    /**
     * Create a new HashedPassword object from a pre-made salt and hash. Should only be used for loading a hashed password from the database; use the HashedPassword(password) constructor if you want to create a hash of a new password.
     * @param salt A byte array of length SecurityParameters.PASSWORD_SALT_LENGTH_BYTES. MUST be different for every password. MUST be generated by a cryptographically secure random number generator.
     * @param hash A byte array of length SecurityParameters.PASSWORD_HASH_LENGTH_BYTES. See the implementation of hashedPassword.hashPassword() for the algorithm that must be used to generate this.
     */
    public HashedPassword(byte[] salt, byte[] hash) {
        this.salt = salt;
        this.hash = hash;
    }

    /**
     * Create a new HashedPassword by hashing a given plaintext password. This will internally generate a secure random salt. Note that a new random salt is created for every password.
     * @param password The plaintext password to hash.
     */
    public HashedPassword(char[] password) {
        SecureRandom rng = new SecureRandom();
        salt = new byte[SecurityParameters.PASSWORD_SALT_LENGTH_BYTES];
        rng.nextBytes(salt);
        hashPassword(salt, password);
    }

    /**
     * Create a new HashedPassword by hashing a given plaintext password with a given salt. Should only be used for hashing a user-entered password for comparison with the correct hash in the database; use the HashedPassword(password) constructor if you want to create a hash of a new password.
     * @param salt The binary data of the salt, loaded from the database.
     * @param password The plaintext password that the user inputted.
     */
    public HashedPassword(byte[] salt, char[] password) {
        hashPassword(salt, password);
    }

    /**
     * Take a plaintext password entered by a user and compare it to the hash and salt of this object in order to check if the password is correct.
     * @param password The plaintext password inputted by a user trying to log in.
     * @return true if the password was correct. false if the password was wrong.
     */
    public boolean validate(char[] password) {
        HashedPassword possiblePassword = new HashedPassword(salt, password);
        byte[] possibleHash = possiblePassword.getHash();
        Arrays.fill(password, '\0');
        return slowEquals(possibleHash, hash);
    }

    /**
     * Retrieve the raw binary data of the salt.
     * @return The raw binary data of the salt. Will be SecurityParameters.PASSWORD_SALT_LENGTH_BYTES bytes long.
     */
    public byte[] getSalt() {
        return salt;
    }

    /**
     * Retrieve the raw binary data of the hash.
     * @return The raw binary data of the hash. Will be SecurityParameters.PASSWORD_HASH_LENGTH_BYTES bytes long.
     */
    public byte[] getHash() {
        return hash;
    }

    /**
     * Explicitly zero out the memory that contains the salt and hash. Recommended to do this after you finish using the object so that the salts and hashes don't stay around in RAM.
     */
    public void erase() {
        Arrays.fill(salt, (byte) 0);
        Arrays.fill(hash, (byte) 0);
    }
}
