/*
 * Copyright 2020 Oliver Trevor and Suchin Ravi.
 *
 * This file is part of MarkSpace.
 *
 * MarkSpace is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MarkSpace is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MarkSpace.  If not, see <https://www.gnu.org/licenses/>.
 */

package security;

/** @file HashedPassword.java
 * The binary data of a hashed password, with some convenience functions for using it safely. Should only be used by other security.* classes and by storage.DatabaseStorage.
 * Use security.PasswordSecurity for all password-related stuff; never use this class directly from the outside (controllers, etc.).
 * @see security.HashedPassword
 */

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

/**
 * A class that represents the binary data of a hashed password. This includes both the salt and the hash itself.
 * This class also has convenience functions for safely verifying a password using the hash.
 * See https://crackstation.net/hashing-security.htm and https://www.baeldung.com/java-password-hashing.
 */

public class HashedPassword {
    /**
     * The binary data of the salt.
     */
    private byte[] salt;

    /**
     * The binary data of the hash itself.
     */
    private byte[] hash;

    /**
     * Constant-time byte array comparison. Used to compare hashes in such a way that an attacker cannot deduce anything
     * by the amount of time it takes to check a hash.
     * Source: https://crackstation.net/hashing-security.htm
     * @param a A byte array to compare with b.
     * @param b A byte array to compare with a.
     * @return Returns true if they are equal, false if they are not.
     */
    private static boolean slowEquals(byte[] a, byte[] b) {
        int diff = a.length ^ b.length;
        for(int i = 0; i < a.length && i < b.length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    /**
     * Given a plaintext password and salt, hash the password using the salt and store the hash in this.hash.
     * @param salt The salt to use with the hash. MUST be SecurityParameters.PASSWORD_SALT_LENGTH_BYTES random bytes. MUST be different for every password. MUST be generated by a cryptographically secure random number generator.
     * @param password The plaintext password to hash.
     */
    private void hashPassword(byte[] salt, String password) {
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, SecurityParameters.PASSWORD_HASH_ITERATION_COUNT, SecurityParameters.PASSWORD_HASH_LENGTH_BYTES * 8);
        SecretKeyFactory secretKeyFactory;
        try {
            secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");
            hash = secretKeyFactory.generateSecret(keySpec).getEncoded();
        }
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            System.out.println("\033[1;31mFATAL ERROR: Cannot find password hashing algorithm 'PBKDF2WithHmacSHA512'.\033[0m");
            System.exit(-1);
        }
        catch (InvalidKeySpecException e) {
            e.printStackTrace();
            System.out.println("\033[1;31mFATAL ERROR: Invalid key spec exception.\033[0m");
            System.exit(-1);
        }
    }

    /**
     * Create a new HashedPassword object from a pre-made salt and hash. Should only be used for loading a hashed password from the database; use the HashedPassword(password) constructor if you want to create a hash of a new password.
     * @param salt A byte array of length SecurityParameters.PASSWORD_SALT_LENGTH_BYTES. MUST be different for every password. MUST be generated by a cryptographically secure random number generator.
     * @param hash A byte array of length SecurityParameters.PASSWORD_HASH_LENGTH_BYTES. See the implementation of hashedPassword.hashPassword() for the algorithm that must be used to generate this.
     */
    public HashedPassword(byte[] salt, byte[] hash) {
        this.salt = salt;
        this.hash = hash;
    }

    /**
     * Create a new HashedPassword by hashing a given plaintext password. This will internally generate a secure random salt. Note that a new random salt is created for every password.
     * @param password The plaintext password to hash.
     */
    public HashedPassword(String password) {
        SecureRandom rng = new SecureRandom();
        salt = new byte[SecurityParameters.PASSWORD_SALT_LENGTH_BYTES];
        rng.nextBytes(salt);
        hashPassword(salt, password);
    }

    /**
     * Create a new HashedPassword by hashing a given plaintext password with a given salt. Should only be used for hashing a user-entered password for comparison with the correct hash in the database; use the HashedPassword(password) constructor if you want to create a hash of a new password.
     * @param salt The binary data of the salt, loaded from the database.
     * @param password The plaintext password that the user inputted.
     */
    public HashedPassword(byte[] salt, String password) {
        hashPassword(salt, password);
    }

    /**
     * Take a plaintext password entered by a user and compare it to the hash and salt of this object in order to check if the password is correct.
     * @param password The plaintext password inputted by a user trying to log in.
     * @return true if the password was correct. false if the password was wrong.
     */
    public boolean validate(String password) {
        HashedPassword possiblePassword = new HashedPassword(salt, password);
        byte[] possibleHash = possiblePassword.getHash();
        return slowEquals(possibleHash, hash);
    }

    /**
     * Retrieve the raw binary data of the salt.
     * @return The raw binary data of the salt. Will be SecurityParameters.PASSWORD_SALT_LENGTH_BYTES bytes long.
     */
    public byte[] getSalt() {
        return salt;
    }

    /**
     * Retrieve the raw binary data of the hash.
     * @return The raw binary data of the hash. Will be SecurityParameters.PASSWORD_HASH_LENGTH_BYTES bytes long.
     */
    public byte[] getHash() {
        return hash;
    }
}
